'use client';

import React, { createContext, useState, useContext, ReactNode, useRef, useEffect, useMemo } from 'react';
import { sendMessage } from '@/lib/telegram';
import { useData } from './DataProviderContext';
import { calculateSMA, calculateRSI, calculateBollingerBands, calculateEMA, calculateMACD } from '@/lib/utils';

// --- Interface ì •ì˜ë“¤ ---
interface Asset {
  market: string;
  quantity: number;
  avg_buy_price: number;
}
interface Transaction {
  id: string;
  type: 'buy' | 'sell' | 'deposit' | 'withdraw';
  market: string;
  price: number;
  amount: number;
  timestamp: string;
  source: string; // 'manual' or strategy ID
  isAuto?: boolean;
  strategyType?: string;
}
interface DcaConfig {
  strategyType: 'dca';
  market: string;
  amount: number;
  interval: string;
}

interface MaConfig {
  strategyType: 'ma';
  market: string;
  shortPeriod: number;
  longPeriod: number;
}

interface RsiConfig {
  strategyType: 'rsi';
  market: string;
  period: number;
  buyThreshold: number;
  sellThreshold: number;
}

interface BBandConfig {
  strategyType: 'bband';
  market: string;
  period: number;
  multiplier: number;
}

interface NewsStrategyConfig {
  strategyType: 'news';
  market: string;
  sentimentThreshold: 'positive' | 'negative'; // e.g., 'positive' to buy on good news, 'negative' to sell on bad news
}

interface VolatilityBreakoutConfig {
  strategyType: 'volatility';
  market: string;
  multiplier: number; // ë³€ë™ì„± ëŒíŒŒ ìŠ¹ìˆ˜ (ê¸°ë³¸ê°’: 0.5)
}

interface MomentumConfig {
  strategyType: 'momentum';
  market: string;
  period: number; // ëª¨ë©˜í…€ ê³„ì‚° ê¸°ê°„ (ê¸°ë³¸ê°’: 10)
  threshold: number; // ëª¨ë©˜í…€ ì„ê³„ê°’ (ê¸°ë³¸ê°’: 5%)
}

interface GridConfig {
  strategyType: 'grid';
  market: string;
  minPrice: number;
  maxPrice: number;
  gridLines: number;
  amountPerGrid: number;
  // Runtime state
  positions?: { [price: number]: number }; // price -> quantity
  lastPrice?: number;
}

interface AiAutoConfig {
  strategyType: 'ai_autonomous';
  market: string;
  interval: string; // e.g., 'minute60'
  confidenceThreshold: number; // 0.0 - 1.0
}

export interface CustomCondition {
  indicator: 'RSI' | 'SMA' | 'EMA' | 'Price' | 'MACD' | 'BollingerUpper' | 'BollingerLower' | 'Volume';
  period?: number;
  operator: '>' | '<' | '>=' | '<=' | '==';
  value: number;
}

interface CustomStrategyConfig {
  strategyType: 'custom';
  market: string;
  buyConditions: CustomCondition[];
  sellConditions: CustomCondition[];
  buyAmountPct: number;
  sellAmountPct: number;
}

export type Strategy = (DcaConfig | MaConfig | RsiConfig | BBandConfig | NewsStrategyConfig | VolatilityBreakoutConfig | MomentumConfig | GridConfig | CustomStrategyConfig | AiAutoConfig) & {
  id: string;
  isActive: boolean;
  name?: string;
  description?: string;
  trailingStop?: {
    isActive: boolean;
    activationPct: number; // e.g., 5% profit to activate
    distancePct: number; // e.g., 2% drop from high to sell
  };
};

interface PortfolioContextType {
  cash: number;
  assets: Asset[];
  transactions: Transaction[];
  strategies: Strategy[];
  buyAsset: (market: string, price: number, amount: number, source: string, strategyType: string, isAuto: boolean) => Promise<boolean>;
  sellAsset: (market: string, price: number, amount: number, source: string, strategyType: string, isAuto: boolean) => Promise<boolean>;
  depositAsset: (market: string, price: number, amount: number, source: string) => Promise<boolean>;
  startStrategy: (strategy: Omit<Strategy, 'id' | 'isActive'>) => void;
  stopStrategy: (strategyId: string) => void;
  circuitBreaker: CircuitBreakerConfig;
  setCircuitBreakerConfig: (config: Partial<CircuitBreakerConfig>) => void;
  refreshTransactions: () => void;
  settings: any; // Added settings property
}

export interface CircuitBreakerConfig {
  isActive: boolean;
  threshold: number; // e.g., 5 for -5%
  triggered: boolean;
  triggeredAt?: string;
}

const PortfolioContext = createContext<PortfolioContextType | undefined>(undefined);

const INITIAL_CASH = 100000; // ê¸°ë³¸ ì›ê¸ˆ: 100,000 KRW (í…ŒìŠ¤íŠ¸ìš©)

export const PortfolioProvider = ({ children }: { children: ReactNode }) => {
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [strategies, setStrategies] = useState<Strategy[]>([]);
  const [circuitBreaker, setCircuitBreaker] = useState<CircuitBreakerConfig>({
    isActive: false,
    threshold: 5,
    triggered: false
  });
  const [settings, setSettings] = useState<any>({}); // New state for all settings

  const startOfDayValueRef = useRef<number>(INITIAL_CASH);
  const { tickers } = useData();

  const strategyIntervalsRef = useRef<{ [key: string]: NodeJS.Timeout }>({});
  // prevent overlapping executions per strategy
  const strategyRunningRef = useRef<{ [key: string]: boolean }>({});
  // Fix: Use ref to access latest tickers inside setInterval closure
  const tickersRef = useRef(tickers);
  const transactionsRef = useRef(transactions);
  const strategiesRef = useRef(strategies);

  useEffect(() => {
    tickersRef.current = tickers;
  }, [tickers]);

  useEffect(() => {
    transactionsRef.current = transactions;
  }, [transactions]);

  useEffect(() => {
    strategiesRef.current = strategies;
  }, [strategies]);



  const fetchTransactions = async () => {
    try {
      const response = await fetch('/api/transactions');
      const data = await response.json();
      if (Array.isArray(data)) {
        setTransactions(data);
      } else {
        console.error('Fetched transactions is not an array:', data);
        setTransactions([]);
      }
    } catch (error) {
      console.error('Error fetching transactions:', error);
      setTransactions([]);
    }
  };

  const refreshTransactions = () => {
    fetchTransactions();
  };

  const fetchStrategies = async () => {
    try {
      const response = await fetch('/api/strategies');
      const data = await response.json();

      if (Array.isArray(data)) {
        setStrategies(data);
        data.forEach((s: Strategy) => {
          if (s.isActive) {
            let intervalMilliseconds = 30000;
            if (s.strategyType === 'dca') {
              intervalMilliseconds = { daily: 24000, weekly: 60000, monthly: 300000 }[s.interval] || 24000;
            } else if (s.strategyType === 'news') {
              intervalMilliseconds = 300000;
            } else if (s.strategyType === 'volatility' || s.strategyType === 'momentum') {
              intervalMilliseconds = 60000;
            } else if (s.strategyType === 'ai_autonomous') {
              // Parse interval string to ms, default to 1 hour if unknown
              const intervalMap: { [key: string]: number } = {
                'minute1': 60000,
                'minute3': 180000,
                'minute5': 300000,
                'minute10': 600000,
                'minute15': 900000,
                'minute30': 1800000,
                'minute60': 3600000,
                'minute240': 14400000,
                'day': 86400000
              };
                              intervalMilliseconds = intervalMap[(s as AiAutoConfig).interval] || 3600000;            }
            const intervalId = setInterval(() => executeStrategy(s), intervalMilliseconds);
            strategyIntervalsRef.current[s.id] = intervalId;
          }
        });
      } else {
        console.warn('Fetched strategies data is not an array:', data);
        setStrategies([]);
      }
    } catch (error) {
      console.error('Error fetching strategies:', error);
      setStrategies([]);
    }
  };

  const fetchSettings = async () => {
    try {
      const response = await fetch('/api/settings');
      if (response.ok) {
        const fetchedSettings = await response.json();
        setSettings(fetchedSettings); // Update the new settings state
        if (fetchedSettings.circuitBreaker) {
          setCircuitBreaker(fetchedSettings.circuitBreaker);
        }
      }
    } catch (error) {
      console.error('Error fetching settings:', error);
    }
  };

  useEffect(() => {
    fetchTransactions();
    fetchStrategies();
    fetchSettings();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const getPortfolioState = (currentTransactions: Transaction[]) => {
    let calculatedCash = INITIAL_CASH;
    const calculatedAssets: { [market: string]: Asset } = {};

    // Process transactions in reverse order (oldest first)
    for (let i = currentTransactions.length - 1; i >= 0; i--) {
      const tx = currentTransactions[i];
      if (tx.type === 'buy') {
        calculatedCash -= tx.price * tx.amount;
        if (calculatedAssets[tx.market]) {
          const existingAsset = calculatedAssets[tx.market];
          const totalQuantity = existingAsset.quantity + tx.amount;
          const totalCost = (existingAsset.avg_buy_price * existingAsset.quantity) + (tx.price * tx.amount);
          calculatedAssets[tx.market] = {
            ...existingAsset,
            quantity: totalQuantity,
            avg_buy_price: totalCost / totalQuantity,
          };
        } else {
          calculatedAssets[tx.market] = {
            market: tx.market,
            quantity: tx.amount,
            avg_buy_price: tx.price,
          };
        }
      } else if (tx.type === 'sell') { // sell
        calculatedCash += tx.price * tx.amount;
        if (calculatedAssets[tx.market]) {
          calculatedAssets[tx.market].quantity -= tx.amount;
        }
      } else if (tx.type === 'deposit') {
        // This is a DEPOSIT of an ASSET, not cash.
        // It adds to our holdings without affecting cash balance.
        if (calculatedAssets[tx.market]) {
          const existingAsset = calculatedAssets[tx.market];
          const totalQuantity = existingAsset.quantity + tx.amount;
          const totalCost = (existingAsset.avg_buy_price * existingAsset.quantity) + (tx.price * tx.amount);
          calculatedAssets[tx.market] = {
            ...existingAsset,
            quantity: totalQuantity,
            avg_buy_price: totalCost / totalQuantity,
          };
        } else {
          calculatedAssets[tx.market] = {
            market: tx.market,
            quantity: tx.amount,
            avg_buy_price: tx.price,
          };
        }
      } else if (tx.type === 'withdraw') {
        // This is a withdrawal of cash.
        calculatedCash -= tx.amount;
      }
    }

    return {
      assets: Object.values(calculatedAssets).filter(a => a.quantity > 0.00001),
      cash: calculatedCash,
    };
  };

  const { assets, cash } = useMemo(() => getPortfolioState(transactions), [transactions]);

  const addTransaction = async (
    type: 'buy' | 'sell' | 'deposit' | 'withdraw',
    market: string,
    price: number,
    amount: number,
    source: string,
    strategyType: string,
    isAuto: boolean
  ): Promise<boolean> => {
    const newTransaction: Transaction = {
      id: new Date().toISOString() + Math.random(),
      type,
      market,
      price,
      amount,
      timestamp: new Date().toISOString(),
      source,
      isAuto,
      strategyType,
    };

    // Optimistic update
    setTransactions(prevTransactions => [newTransaction, ...prevTransactions]);

    try {
      const response = await fetch('/api/transactions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTransaction),
      });
      if (!response.ok) {
        const errorData = await response.json();
        console.error('Failed to save transaction, reverting optimistic update.', errorData.details || errorData.error);
        // Revert on failure
        setTransactions(prevTransactions => prevTransactions.filter(tx => tx.id !== newTransaction.id));
        return false;
      }
      return true;
    } catch (error) {
      console.error('Error saving transaction, reverting optimistic update:', error);
      // Revert on error
      setTransactions(prevTransactions => prevTransactions.filter(tx => tx.id !== newTransaction.id));
      return false;
    }
  };

  const depositAsset = async (market: string, price: number, amount: number, source: string): Promise<boolean> => {
    // Deposits don't affect cash, so no validation against cash is needed.
    // We also don't check for circuit breaker on deposits.
    return await addTransaction('deposit', market, price, amount, source, 'manual_deposit', false);
  };


  const buyAsset = async (market: string, price: number, amount: number, source: string, strategyType: string, isAuto: boolean): Promise<boolean> => {
    const cost = price * amount;
    const { cash: currentCash } = getPortfolioState(transactions);

    // ìµœì†Œ ê±°ë˜ ê¸ˆì•¡ (5000ì›) ì²´í¬
    if (cost < 5000) {
      console.log(`[${market}] ë§¤ìˆ˜ ê¸ˆì•¡ì´ ìµœì†Œ ê±°ë˜ ê¸ˆì•¡(5,000ì›)ë³´ë‹¤ ì‘ì•„ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      return false;
    }

    // ì„œí‚· ë¸Œë ˆì´ì»¤ ì²´í¬
    if (circuitBreaker.triggered) {
      console.warn('â›” ì„œí‚· ë¸Œë ˆì´ì»¤ê°€ ë°œë™ë˜ì–´ ë§¤ìˆ˜ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
      return false;
    }

    if (currentCash < cost) {
      console.error(`[${market}] í˜„ê¸ˆì´ ë¶€ì¡±í•˜ì—¬ ë§¤ìˆ˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (í•„ìš”: ${cost.toLocaleString()}ì›, ë³´ìœ : ${currentCash.toLocaleString()}ì›)`);
      return false;
    }

    return await addTransaction('buy', market, price, amount, source, strategyType, isAuto);
  };

  const sellAsset = async (market: string, price: number, amount: number, source: string, strategyType: string, isAuto: boolean): Promise<boolean> => {
    const { assets: currentAssets } = getPortfolioState(transactions);
    const existingAsset = currentAssets.find(a => a.market === market);

    // ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ì²´í¬ (0.00001ì™€ ê°™ì€ ì‘ì€ ì˜¤ì°¨ í—ˆìš©)
    if (!existingAsset || existingAsset.quantity < amount - 0.00001) {
      console.error(`[${market}] ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ì´ ë¶€ì¡±í•˜ì—¬ ë§¤ë„í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ìš”ì²­: ${amount}, ë³´ìœ : ${existingAsset?.quantity || 0})`);
      return false;
    }

    // ì‹¤ì œ ë§¤ë„ ìˆ˜ëŸ‰ì€ ë³´ìœ  ìˆ˜ëŸ‰ìœ¼ë¡œ ì œí•œ
    const sellAmount = Math.min(amount, existingAsset.quantity);

    return await addTransaction('sell', market, price, sellAmount, source, strategyType, isAuto);
  };

  // --- Strategy Execution ---
  const executeStrategy = async (strategy: Strategy) => {
    // Check if AI autonomous trading is globally enabled if this is an AI strategy
    if (strategy.strategyType === 'ai_autonomous' && !settings.isAIAutoTradingEnabled) {
      console.log(`[${strategy.market}] AI ììœ¨ ë§¤ë§¤ ë¹„í™œì„±í™”ë¨. ì‹¤í–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
      return;
    }

    const currentTickers = tickersRef.current;
    if (!strategy.isActive || currentTickers.length === 0) return;

    const ticker = currentTickers.find(t => t.market === strategy.market);
    if (!ticker) return;

    if (strategy.strategyType === 'dca') {
      try {
        const currentPrice = ticker.trade_price;
        const change24h = ticker.signed_change_rate * 100 || 0;

        // AI ê²€ì¦ (ì˜µì…˜, í™˜ê²½ë³€ìˆ˜ë¡œ í™œì„±í™”)
        const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
        if (useAI) {
          try {
            const aiResponse = await fetch('/api/ai/analyze', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                market: strategy.market,
                currentPrice,
                change24h,
              }),
            });

            if (aiResponse.ok) {
              const aiData = await aiResponse.json();
              const analysis = aiData.analysis;

              if (analysis.recommendation === 'ë§¤ë„' && analysis.confidence > 0.7) {
                console.log(`[${strategy.market}] AIê°€ DCA ë§¤ìˆ˜ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${analysis.reasoning}`);
                return;
              }

              let amountToBuy = strategy.amount / currentPrice;
              if (analysis.recommendation === 'ë§¤ìˆ˜' && analysis.recommended_amount_percent) {
                const adjustedAmount = strategy.amount * (analysis.recommended_amount_percent / 100);
                amountToBuy = adjustedAmount / currentPrice;
                console.log(`[${strategy.market}] AI ì¶”ì²œì— ë”°ë¼ ë§¤ìˆ˜ ê¸ˆì•¡ ì¡°ì •: ${analysis.recommended_amount_percent}%`);
              }

              buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
            } else {
              const amountToBuy = strategy.amount / currentPrice;
              buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
            }
          } catch (aiError) {
            console.warn('AI ê²€ì¦ ì‹¤íŒ¨, ê¸°ë³¸ DCA ì‹¤í–‰:', aiError);
            const amountToBuy = strategy.amount / currentPrice;
            buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
          }
        } else {
          const amountToBuy = strategy.amount / currentPrice;
          buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
        }
      } catch (error) { console.error('DCA ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'ma') {
      try {
        const response = await fetch(`/api/candles?market=${strategy.market}&count=${strategy.longPeriod + 2}`);
        const candles = await response.json();
        if (candles.length < strategy.longPeriod + 2) return;

        const reversedCandles = [...candles].reverse();
        const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);

        const shortMA = calculateSMA(reversedCandles, strategy.shortPeriod);
        const longMA = calculateSMA(reversedCandles, strategy.longPeriod);

        if (shortMA.length < 2 || longMA.length < 2) return;

        const lastShort = shortMA[shortMA.length - 1];
        const lastLong = longMA[longMA.length - 1];
        const prevShort = shortMA[shortMA.length - 2];
        const prevLong = longMA[longMA.length - 2];
        const currentPrice = ticker.trade_price;

        const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
        let aiAnalysis: any = null;

        if (useAI) {
          try {
            const aiResponse = await fetch('/api/ai/analyze', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                market: strategy.market,
                currentPrice,
                change24h: ticker.signed_change_rate * 100,
                ma: {
                  short: lastShort,
                  long: lastLong,
                  cross: lastShort > lastLong && prevShort <= prevLong ? 'golden' :
                    lastShort < lastLong && prevShort >= prevLong ? 'dead' : 'none',
                },
              }),
            });

            if (aiResponse.ok) {
              const aiData = await aiResponse.json();
              aiAnalysis = aiData.analysis;
            }
          } catch (aiError) {
            console.warn('MA ì „ëµ AI ê²€ì¦ ì‹¤íŒ¨:', aiError);
          }
        }

        if (lastShort > lastLong && prevShort <= prevLong) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ë„' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ ê³¨ë“ í¬ë¡œìŠ¤ ë§¤ìˆ˜ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const krwAmount = currentCash * 0.5;
          if (krwAmount > 5000) {
            const amountToBuy = krwAmount / currentPrice;
            buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
          }
        }
        else if (lastShort < lastLong && prevShort >= prevLong) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ìˆ˜' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ ë°ë“œí¬ë¡œìŠ¤ ë§¤ë„ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const assetToSell = currentAssets.find(a => a.market === strategy.market);
          if (assetToSell && assetToSell.quantity > 0) {
            sellAsset(strategy.market, currentPrice, assetToSell.quantity, strategy.id, strategy.strategyType, true);
          }
        }
      } catch (error) { console.error('MA ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'rsi') {
      try {
        const response = await fetch(`/api/candles?market=${strategy.market}&count=${strategy.period + 1}`);
        const candles = await response.json();
        if (candles.length < strategy.period + 1) return;

        const reversedCandles = [...candles].reverse();
        const rsi = calculateRSI(reversedCandles, strategy.period);
        const lastRsi = rsi[rsi.length - 1];
        const currentPrice = ticker.trade_price;
        const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);

        const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
        let aiAnalysis: any = null;

        if (useAI) {
          try {
            const aiResponse = await fetch('/api/ai/analyze', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                market: strategy.market,
                currentPrice,
                change24h: ticker.signed_change_rate * 100,
                rsi: lastRsi,
              }),
            });

            if (aiResponse.ok) {
              const aiData = await aiResponse.json();
              aiAnalysis = aiData.analysis;
            }
          } catch (aiError) {
            console.warn('RSI ì „ëµ AI ê²€ì¦ ì‹¤íŒ¨:', aiError);
          }
        }

        if (lastRsi < strategy.buyThreshold) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ë„' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ RSI ê³¼ë§¤ë„ ë§¤ìˆ˜ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const krwAmount = currentCash * 0.5;
          if (krwAmount > 5000) {
            const amountToBuy = krwAmount / currentPrice;
            buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
          }
        } else if (lastRsi > strategy.sellThreshold) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ìˆ˜' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ RSI ê³¼ë§¤ìˆ˜ ë§¤ë„ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const assetToSell = currentAssets.find(a => a.market === strategy.market);
          if (assetToSell && assetToSell.quantity > 0) {
            sellAsset(strategy.market, currentPrice, assetToSell.quantity, strategy.id, strategy.strategyType, true);
          }
        }
      } catch (error) { console.error('RSI ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'bband') {
      try {
        const response = await fetch(`/api/candles?market=${strategy.market}&count=${strategy.period + 1}`);
        const candles = await response.json();
        if (candles.length < strategy.period + 1) return;

        const reversedCandles = [...candles].reverse();
        const bb = calculateBollingerBands(reversedCandles, strategy.period, strategy.multiplier);

        const currentPrice = ticker.trade_price;
        const lastUpper = bb.upper[bb.upper.length - 1];
        const lastLower = bb.lower[bb.lower.length - 1];
        const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);

        const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
        let aiAnalysis: any = null;

        if (useAI) {
          try {
            const bollingerPosition = currentPrice < lastLower ? 'below' :
              currentPrice > lastUpper ? 'above' : 'middle';
            const aiResponse = await fetch('/api/ai/analyze', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                market: strategy.market,
                currentPrice,
                change24h: ticker.signed_change_rate * 100,
                bollinger: {
                  position: bollingerPosition,
                  upper: lastUpper,
                  lower: lastLower,
                  middle: bb.middle[bb.middle.length - 1],
                },
              }),
            });

            if (aiResponse.ok) {
              const aiData = await aiResponse.json();
              aiAnalysis = aiData.analysis;
            }
          } catch (aiError) {
            console.warn('ë³¼ë¦°ì €ë°´ë“œ ì „ëµ AI ê²€ì¦ ì‹¤íŒ¨:', aiError);
          }
        }

        if (currentPrice < lastLower) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ë„' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ ë³¼ë¦°ì €ë°´ë“œ í•˜ë‹¨ ë§¤ìˆ˜ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const krwAmount = currentCash * 0.5;
          if (krwAmount > 5000) {
            const amountToBuy = krwAmount / currentPrice;
            buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
          }
        } else if (currentPrice > lastUpper) {
          if (aiAnalysis && aiAnalysis.recommendation === 'ë§¤ìˆ˜' && aiAnalysis.confidence > 0.7) {
            console.log(`[${strategy.market}] AIê°€ ë³¼ë¦°ì €ë°´ë“œ ìƒë‹¨ ë§¤ë„ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤. ì´ìœ : ${aiAnalysis.reasoning}`);
            return;
          }

          const assetToSell = currentAssets.find(a => a.market === strategy.market);
          if (assetToSell && assetToSell.quantity > 0) {
            sellAsset(strategy.market, currentPrice, assetToSell.quantity * 0.5, strategy.id, strategy.strategyType, true);
          }
        }
      } catch (error) { console.error('BBand ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'news') {
      // Prevent re-entrancy: if this strategy is already running, skip this tick
      if (strategyRunningRef.current[strategy.id]) {
        return;
      }
      strategyRunningRef.current[strategy.id] = true;
      try {
        // Support global news scanner: market === 'ALL' or '*'
        const isGlobal = strategy.market === 'ALL' || strategy.market === '*';

        // Helper to process a single market's news
        const processMarket = async (marketCode: string) => {
          try {
            const query = marketCode.replace('KRW-', '');
            const response = await fetch(`/api/news?query=${encodeURIComponent(query)}&language=ko`);
            const newsArticles = await response.json();

            const relevantNews = Array.isArray(newsArticles)
              ? newsArticles.filter((article: any) => article.title && article.title.toLowerCase().includes(query.toLowerCase()))
              : [];

            if (relevantNews.length === 0) return;

            const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);
            const tickerForMarket = tickers.find(t => t.market === marketCode);
            const currentPriceForMarket = tickerForMarket?.trade_price;

            if (!currentPriceForMarket) {
              console.error(`[${marketCode}] í˜„ì¬ ê°€ê²©ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
              return;
            }

            const hasPositiveNews = relevantNews.some((article: any) => article.sentiment === 'positive');
            const hasNegativeNews = relevantNews.some((article: any) => article.sentiment === 'negative');

            // sentimentThreshold: 'positive' | 'negative' | 'both'
            const threshold = (strategy as any).sentimentThreshold || 'positive';

            if ((threshold === 'positive' || threshold === 'both') && hasPositiveNews) {
              console.log(`[${marketCode}] í˜¸ì¬ ë‰´ìŠ¤ ê°ì§€! ë§¤ìˆ˜ ì‹¤í–‰`);
              const krwAmount = currentCash * 0.5;
              if (krwAmount > 5000) {
                const amountToBuy = krwAmount / currentPriceForMarket;
                buyAsset(marketCode, currentPriceForMarket, amountToBuy, strategy.id, strategy.strategyType, true);
              }
            }

            if ((threshold === 'negative' || threshold === 'both') && hasNegativeNews) {
              console.log(`[${marketCode}] ì•…ì¬ ë‰´ìŠ¤ ê°ì§€! ë§¤ë„ ì‹¤í–‰`);
              const assetToSell = currentAssets.find(a => a.market === marketCode);
              if (assetToSell && assetToSell.quantity > 0) {
                sellAsset(marketCode, currentPriceForMarket, assetToSell.quantity * 0.5, strategy.id, strategy.strategyType, true);
              }
            }
          } catch (err) {
            console.error('News ì „ëµ ì‹œì¥ ì²˜ë¦¬ ì‹¤íŒ¨:', err);
          }
        };

        if (isGlobal) {
          // Process tickers sequentially to avoid system overload
          const concurrency = 1; // Reduced from 5 to 1 for stability
          const currentTickers = tickersRef.current;
          const krwTickers = currentTickers.filter(t => t.market && t.market.startsWith('KRW-'));
          for (let i = 0; i < krwTickers.length; i += concurrency) {
            const chunk = krwTickers.slice(i, i + concurrency);
            await Promise.all(chunk.map(t => processMarket(t.market)));
            // Increased delay to be very gentle to the system
            // eslint-disable-next-line no-await-in-loop
            await new Promise(r => setTimeout(r, 500));
          }
        } else {
          // specific market
          // eslint-disable-next-line no-await-in-loop
          await processMarket(strategy.market);
        }
      } catch (error) { console.error('News ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
      finally {
        strategyRunningRef.current[strategy.id] = false;
      }
    } else if (strategy.strategyType === 'volatility') {
      try {
        const response = await fetch(`/api/candles?market=${strategy.market}&count=2`);
        const candles = await response.json();
        if (candles.length < 2) return;

        const yesterday = candles[1];
        const currentPrice = ticker.trade_price;
        const range = yesterday.high_price - yesterday.low_price;
        const targetPrice = yesterday.high_price + (range * strategy.multiplier);

        if (currentPrice > targetPrice) {
          const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
          let aiAnalysis: any = null;

          if (useAI) {
            try {
              const aiResponse = await fetch('/api/ai/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  market: strategy.market,
                  currentPrice,
                  change24h: ticker.signed_change_rate * 100,
                  volatility: {
                    range,
                    targetPrice,
                    isBreakout: true,
                  },
                }),
              });

              if (aiResponse.ok) {
                const aiData = await aiResponse.json();
                aiAnalysis = aiData.analysis;
              }
            } catch (aiError) {
              console.warn('ë³€ë™ì„± ëŒíŒŒ ì „ëµ AI ê²€ì¦ ì‹¤íŒ¨:', aiError);
            }
          }

          if (!aiAnalysis || (aiAnalysis.recommendation === 'ë§¤ìˆ˜' && aiAnalysis.confidence > 0.6)) {
            const { cash: currentCash } = getPortfolioState(transactionsRef.current);
            const krwAmount = currentCash * 0.3;
            if (krwAmount > 5000) {
              const amountToBuy = krwAmount / currentPrice;
              buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
              console.log(`[${strategy.market}] ë³€ë™ì„± ëŒíŒŒ ë°œìƒ! ë§¤ìˆ˜ ì‹¤í–‰ (ëª©í‘œê°€: ${targetPrice.toLocaleString()})`);
            }
          } else {
            console.log(`[${strategy.market}] AIê°€ ë³€ë™ì„± ëŒíŒŒë¥¼ ê°€ì§œ ëŒíŒŒë¡œ íŒë‹¨í–ˆìŠµë‹ˆë‹¤.`);
          }
        }
      } catch (error) { console.error('ë³€ë™ì„± ëŒíŒŒ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'momentum') {
      try {
        const response = await fetch(`/api/candles?market=${strategy.market}&count=${strategy.period + 1}`);
        const candles = await response.json();
        if (candles.length < strategy.period + 1) return;

        const reversedCandles = [...candles].reverse();
        const currentPrice = ticker.trade_price;
        const pastPrice = reversedCandles[reversedCandles.length - strategy.period - 1].trade_price;

        const priceMomentum = ((currentPrice - pastPrice) / pastPrice) * 100;

        const recentVolumes = reversedCandles.slice(-strategy.period).map(c => c.candle_acc_trade_volume || 0);
        const avgVolume = recentVolumes.reduce((a, b) => a + b, 0) / recentVolumes.length;
        const currentVolume = recentVolumes[recentVolumes.length - 1] || 0;
        const volumeMomentum = currentVolume > 0 ? ((currentVolume - avgVolume) / avgVolume) * 100 : 0;

        if (priceMomentum > strategy.threshold && volumeMomentum > 20) {
          const useAI = process.env.NEXT_PUBLIC_USE_AI_VERIFICATION === 'true';
          let aiAnalysis: any = null;

          if (useAI) {
            try {
              const rsi = calculateRSI(reversedCandles, 14);
              const lastRsi = rsi.length > 0 ? rsi[rsi.length - 1] : 50;

              const aiResponse = await fetch('/api/ai/analyze', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  market: strategy.market,
                  currentPrice,
                  change24h: priceMomentum,
                  rsi: lastRsi,
                  momentum: {
                    priceMomentum,
                    volumeMomentum,
                    isStrong: priceMomentum > strategy.threshold * 2,
                  },
                }),
              });

              if (aiResponse.ok) {
                const aiData = await aiResponse.json();
                aiAnalysis = aiData.analysis;
              }
            } catch (aiError) {
              console.warn('ëª¨ë©˜í…€ ì „ëµ AI ê²€ì¦ ì‹¤íŒ¨:', aiError);
            }
          }

          if (!aiAnalysis || (aiAnalysis.recommendation === 'ë§¤ìˆ˜' && aiAnalysis.confidence > 0.65)) {
            const { cash: currentCash } = getPortfolioState(transactionsRef.current);
            const krwAmount = currentCash * 0.4;
            if (krwAmount > 5000) {
              const amountToBuy = krwAmount / currentPrice;
              buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
              console.log(`[${strategy.market}] ëª¨ë©˜í…€ ë°œìƒ! ë§¤ìˆ˜ ì‹¤í–‰ (ê°€ê²© ëª¨ë©˜í…€: ${priceMomentum.toFixed(2)}%, ê±°ë˜ëŸ‰ ëª¨ë©˜í…€: ${volumeMomentum.toFixed(2)}%)`);
            }
          } else {
            console.log(`[${strategy.market}] AIê°€ ëª¨ë©˜í…€ ì§€ì† ê°€ëŠ¥ì„±ì„ ë‚®ê²Œ í‰ê°€í–ˆìŠµë‹ˆë‹¤.`);
          }
        }
      } catch (error) { console.error('ëª¨ë©˜í…€ ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'grid') {
      // Use latest state
      const currentStrategy = strategiesRef.current.find(s => s.id === strategy.id);
      if (!currentStrategy || currentStrategy.strategyType !== 'grid') return;

      const { minPrice, maxPrice, gridLines, amountPerGrid } = currentStrategy;
      const step = (maxPrice - minPrice) / gridLines;
      const currentPrice = ticker.trade_price;

      // Initialize state if first run
      let positions = currentStrategy.positions || {};
      let lastPrice = currentStrategy.lastPrice || currentPrice;
      let updated = false;

      // Check crossings
      for (let i = 0; i <= gridLines; i++) {
        const linePrice = minPrice + (step * i);

        // Buy: Crossed Down (Last > Line >= Current)
        if (lastPrice > linePrice && currentPrice <= linePrice) {
          if (!positions[i]) {
            const quantity = amountPerGrid / currentPrice;
            const success = await buyAsset(strategy.market, currentPrice, quantity, strategy.id, 'grid', true);
            if (success) {
              positions = { ...positions, [i]: quantity };
              updated = true;
              console.log(`[Grid] #${i} ë§¤ìˆ˜ ì²´ê²°: ${linePrice.toLocaleString()}ì›`);
            }
          }
        }

        // Sell: Crossed Up (Last < Line <= Current)
        // Sell the position from the level below (i-1) when crossing line i upwards
        if (lastPrice < linePrice && currentPrice >= linePrice) {
          const sellIndex = i - 1;
          if (positions[sellIndex]) {
            const quantity = positions[sellIndex];
            const success = await sellAsset(strategy.market, currentPrice, quantity, strategy.id, 'grid', true);
            if (success) {
              const newPositions = { ...positions };
              delete newPositions[sellIndex];
              positions = newPositions;
              updated = true;
              console.log(`[Grid] #${sellIndex} ë§¤ë„ ì²´ê²°: ${linePrice.toLocaleString()}ì› (ë§¤ìˆ˜ê°€: ${(minPrice + step * sellIndex).toLocaleString()})`);
            }
          }
        }
      }

      if (updated || currentStrategy.lastPrice !== currentPrice) {
        updateStrategy(strategy.id, { positions, lastPrice: currentPrice });
      }
    } else if (strategy.strategyType === 'custom') {
      try {
        // 1. Fetch necessary data (candles)
        // Determine max period needed
        const conditions = [...strategy.buyConditions, ...strategy.sellConditions];
        const maxPeriod = Math.max(...conditions.map(c => c.period || 0), 14) + 5; // Buffer

        const response = await fetch(`/api/candles?market=${strategy.market}&count=${maxPeriod}`);
        const candles = await response.json();
        if (candles.length < maxPeriod) return;

        const reversedCandles = [...candles].reverse();
        const currentPrice = ticker.trade_price;

        // 2. Helper to evaluate a single condition
        const evaluateCondition = (condition: CustomCondition): boolean => {
          let currentValue = 0;

          if (condition.indicator === 'Price') {
            currentValue = currentPrice;
          } else if (condition.indicator === 'RSI') {
            const rsi = calculateRSI(reversedCandles, condition.period || 14);
            currentValue = rsi[rsi.length - 1];
          } else if (condition.indicator === 'SMA') {
            const sma = calculateSMA(reversedCandles, condition.period || 20);
            currentValue = sma[sma.length - 1];
          } else if (condition.indicator === 'EMA') {
            const ema = calculateEMA(reversedCandles, condition.period || 20);
            currentValue = ema[ema.length - 1];
          } else if (condition.indicator === 'MACD') {
            const macd = calculateMACD(reversedCandles);
            // MACD Line vs Signal Line comparison usually, but here we compare MACD Line value
            // Or maybe histogram? Let's use MACD Line value for simplicity against a threshold
            currentValue = macd.macdLine[macd.macdLine.length - 1];
          } else if (condition.indicator === 'BollingerUpper') {
            const bb = calculateBollingerBands(reversedCandles, condition.period || 20, 2);
            currentValue = bb.upper[bb.upper.length - 1];
          } else if (condition.indicator === 'BollingerLower') {
            const bb = calculateBollingerBands(reversedCandles, condition.period || 20, 2);
            currentValue = bb.lower[bb.lower.length - 1];
          } else if (condition.indicator === 'Volume') {
            // Volume is not in Candle interface used by utils, need to check if passed candles have volume
            // The candles from /api/candles usually have candle_acc_trade_volume
            const lastCandle = reversedCandles[reversedCandles.length - 1] as any;
            currentValue = lastCandle.candle_acc_trade_volume || 0;
          }

          switch (condition.operator) {
            case '>': return currentValue > condition.value;
            case '<': return currentValue < condition.value;
            case '>=': return currentValue >= condition.value;
            case '<=': return currentValue <= condition.value;
            case '==': return Math.abs(currentValue - condition.value) < 0.0001;
            default: return false;
          }
        };

        // 3. Evaluate Buy Conditions (ALL must be true)
        const buySignal = strategy.buyConditions.length > 0 && strategy.buyConditions.every(evaluateCondition);

        // 4. Evaluate Sell Conditions (ALL must be true)
        const sellSignal = strategy.sellConditions.length > 0 && strategy.sellConditions.every(evaluateCondition);

        const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);

        if (buySignal) {
          const buyAmountPct = strategy.buyAmountPct || 10; // Default 10%
          const krwAmount = currentCash * (buyAmountPct / 100);

          if (krwAmount > 5000) {
            const amountToBuy = krwAmount / currentPrice;
            console.log(`[${strategy.market}] ì»¤ìŠ¤í…€ ì „ëµ ë§¤ìˆ˜ ì‹ í˜¸! (${buyAmountPct}%)`);
            buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
          }
        } else if (sellSignal) {
          const assetToSell = currentAssets.find(a => a.market === strategy.market);
          if (assetToSell && assetToSell.quantity > 0) {
            const sellAmountPct = strategy.sellAmountPct || 50; // Default 50%
            const amountToSell = assetToSell.quantity * (sellAmountPct / 100);
            console.log(`[${strategy.market}] ì»¤ìŠ¤í…€ ì „ëµ ë§¤ë„ ì‹ í˜¸! (${sellAmountPct}%)`);
            sellAsset(strategy.market, currentPrice, amountToSell, strategy.id, strategy.strategyType, true);
          }
        }

      } catch (error) { console.error('Custom ì „ëµ ì‹¤í–‰ ì‹¤íŒ¨:', error); }
    } else if (strategy.strategyType === 'ai_autonomous') {
      // Prevent re-entrancy
      if (strategyRunningRef.current[strategy.id]) {
        console.log(`[${strategy.market}] AI ììœ¨ ë§¤ë§¤ - ì´ë¯¸ ì‹¤í–‰ ì¤‘, ê±´ë„ˆë›°ê¸°`);
        return;
      }
      strategyRunningRef.current[strategy.id] = true;

      try {
        const aiAutoConfig = strategy as AiAutoConfig;
        const currentPrice = ticker.trade_price;
        const { cash: currentCash, assets: currentAssets } = getPortfolioState(transactionsRef.current);
        const asset = currentAssets.find(a => a.market === strategy.market);

        console.log(`[${strategy.market}] AI ììœ¨ ë§¤ë§¤ - ë¶„ì„ ìš”ì²­...`);
        const aiResponse = await fetch('/api/ai/recommend-strategy', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ market: strategy.market }),
        });

        if (!aiResponse.ok) {
          throw new Error('AI ì¶”ì²œ ì „ëµì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
        const aiData = await aiResponse.json();

        const recommendation = aiData.recommendation?.toLowerCase(); // 'buy', 'sell', 'hold'
        const confidence = parseFloat(aiData.confidence); // 0.0 ~ 1.0

        console.log(`[${strategy.market}] AI ì¶”ì²œ: ${recommendation}, ì‹ ë¢°ë„: ${confidence.toFixed(2)}`);

        if (confidence >= aiAutoConfig.confidenceThreshold) {
          if (recommendation === 'buy') {
            const amountToBuy = currentCash * 0.1 / currentPrice; // ê°€ìš© í˜„ê¸ˆì˜ 10% ë§¤ìˆ˜
            if (amountToBuy * currentPrice >= 5000) {
              await buyAsset(strategy.market, currentPrice, amountToBuy, strategy.id, strategy.strategyType, true);
              console.log(`[${strategy.market}] AI ì¶”ì²œ ë§¤ìˆ˜ (${(amountToBuy * currentPrice).toFixed(0)}ì›)`);
            } else {
              console.log(`[${strategy.market}] AI ì¶”ì²œ ë§¤ìˆ˜ ê¸ˆì•¡ì´ ë„ˆë¬´ ì ì–´ ê±´ë„ˆëœë‹ˆë‹¤.`);
            }
          } else if (recommendation === 'sell' && asset && asset.quantity > 0) {
            const amountToSell = asset.quantity * 0.5; // ë³´ìœ ëŸ‰ì˜ 50% ë§¤ë„
            await sellAsset(strategy.market, currentPrice, amountToSell, strategy.id, strategy.strategyType, true);
            console.log(`[${strategy.market}] AI ì¶”ì²œ ë§¤ë„ (${amountToSell.toFixed(4)}ê°œ)`);
          } else {
            console.log(`[${strategy.market}] AI ì¶”ì²œ ë³´ë¥˜ ë˜ëŠ” ë§¤ë„ ì¡°ê±´ ë¶ˆì¶©ì¡±.`);
          }
        } else {
          console.log(`[${strategy.market}] AI ì‹ ë¢°ë„ (${confidence.toFixed(2)})ê°€ ë‚®ì•„ ê±°ë˜ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤.`);
        }
      } catch (error) {
        console.error('AI ììœ¨ ë§¤ë§¤ ì‹¤í–‰ ì‹¤íŒ¨:', error);
      } finally {
        strategyRunningRef.current[strategy.id] = false;
      }
    }
  };

  const startStrategy = async (strategyConfig: Omit<Strategy, 'id' | 'isActive'>) => {
    const newStrategy = {
      ...strategyConfig,
      id: new Date().toISOString() + Math.random(),
      isActive: true,
    } as Strategy;

    try {
      const response = await fetch('/api/strategies', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(newStrategy),
      });
      const savedStrategy = await response.json();
      setStrategies(prev => [...prev, savedStrategy]);

      let intervalMilliseconds = 30000; // default for MA
      if (savedStrategy.strategyType === 'dca') {
        const intervalMap: { [key: string]: number } = { daily: 24000, weekly: 60000, monthly: 300000 };
        intervalMilliseconds = intervalMap[savedStrategy.interval] || 24000;
      } else if (savedStrategy.strategyType === 'news') {
        intervalMilliseconds = 300000; // Check news every 5 minutes
      } else if (savedStrategy.strategyType === 'volatility' || savedStrategy.strategyType === 'momentum' || savedStrategy.strategyType === 'custom') {
        intervalMilliseconds = 60000; // Check every 1 minute
      } else if (savedStrategy.strategyType === 'grid') {
        intervalMilliseconds = 20000; // Check every 20 seconds
      }

      executeStrategy(savedStrategy);
      const intervalId = setInterval(() => executeStrategy(savedStrategy), intervalMilliseconds);
      strategyIntervalsRef.current[savedStrategy.id] = intervalId;

    } catch (error) {
      console.error('Error saving strategy:', error);
    }
  };

  const stopStrategy = async (strategyId: string) => {
    const intervalId = strategyIntervalsRef.current[strategyId];
    if (intervalId) {
      clearInterval(intervalId);
      delete strategyIntervalsRef.current[strategyId];
    }

    // Optimistic update
    setStrategies(prev => prev.filter(s => s.id !== strategyId));

    try {
      await fetch(`/api/strategies?id=${strategyId}`, { method: 'DELETE' });
    } catch (error) {
      console.error('Failed to delete strategy from server:', error);
    }
  };


  const setCircuitBreakerConfig = async (config: Partial<CircuitBreakerConfig>) => {
    setCircuitBreaker(prev => {
      const newState = { ...prev, ...config };
      // Save to server
      fetch('/api/settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ circuitBreaker: newState })
      }).catch(err => console.error('Failed to save circuit breaker settings:', err));
      return newState;
    });
  };



  // Circuit Breaker Monitor
  useEffect(() => {
    if (!circuitBreaker.isActive || circuitBreaker.triggered || tickers.length === 0) return;

    const { cash, assets } = getPortfolioState(transactions);
    let currentTotalValue = cash;

    assets.forEach(asset => {
      const ticker = tickers.find(t => t.market === asset.market);
      if (ticker) {
        currentTotalValue += asset.quantity * ticker.trade_price;
      } else {
        currentTotalValue += asset.quantity * asset.avg_buy_price;
      }
    });

    // Calculate loss percentage from Initial Cash
    const lossPct = ((INITIAL_CASH - currentTotalValue) / INITIAL_CASH) * 100;

    if (lossPct >= circuitBreaker.threshold) {
      setCircuitBreaker(prev => ({
        ...prev,
        triggered: true,
        triggeredAt: new Date().toISOString()
      }));
      console.warn(`âš ï¸ ì„œí‚· ë¸Œë ˆì´ì»¤ ë°œë™! ì†ì‹¤ìœ¨: ${lossPct.toFixed(2)}%`);

      // Optional: Send notification
      sendMessage(`ğŸš¨ <b>ì„œí‚· ë¸Œë ˆì´ì»¤ ë°œë™!</b>\nì†ì‹¤ìœ¨ì´ ${lossPct.toFixed(2)}%ì— ë„ë‹¬í•˜ì—¬ ëª¨ë“  ë§¤ìˆ˜ ì£¼ë¬¸ì´ ì°¨ë‹¨ë©ë‹ˆë‹¤.`);
    }
  }, [tickers, transactions, circuitBreaker]);

  return (
    <PortfolioContext.Provider value={{
      cash,
      assets,
      transactions,
      strategies,
      buyAsset,
      sellAsset,
      depositAsset,
      startStrategy,
      stopStrategy,
      circuitBreaker,
      setCircuitBreakerConfig,
      refreshTransactions,
      settings
    }}>
      {children}
    </PortfolioContext.Provider>
  );
};

export const usePortfolio = () => {
  const context = useContext(PortfolioContext);
  if (context === undefined) {
    throw new Error('usePortfolio must be used within a PortfolioProvider');
  }
  return context;
};
